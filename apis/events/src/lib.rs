use crate::event::EventMessage;
use async_trait::async_trait;
use mbus_nats::{BusResult, BusSubscription};
use serde::{de::DeserializeOwned, Serialize};

mod common;
pub mod event_traits;
pub mod mbus_nats;

#[async_trait]
pub trait Bus {
    /// Publish a message to message bus.
    async fn publish(&mut self, message: &EventMessage) -> BusResult<u64>;
    /// Create a subscription which can be
    /// polled for messages until the bus is closed.
    async fn subscribe<T: Serialize + DeserializeOwned>(&mut self)
        -> BusResult<BusSubscription<T>>;
}

/// Event module for the autogenerated event code.
#[cfg(target_os = "linux")]
pub mod event {
    #![allow(clippy::derive_partial_eq_without_eq)]
    #![allow(clippy::large_enum_variant)]
    tonic::include_proto!("v1.event");
}

// In order to IDE to work properly with event definitions on non-Linux platform,
// one can copy generated bindings (v1.event.rs) from a Linux target and put them to .pregenerated
// directory. This has to be done every time event API is changed.
#[cfg(not(target_os = "linux"))]
pub mod event {
    include!("../../../.pregenerated/v1.event.rs");
}
